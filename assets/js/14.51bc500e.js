(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{301:function(t,e,a){"use strict";a.r(e);var s={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},r=a(7),n=Object(r.a)(s,function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.slotKey}},[a("h1",{attrs:{id:"_1秒钟，极速部署web程序！"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1秒钟，极速部署web程序！","aria-hidden":"true"}},[t._v("#")]),t._v(" 1秒钟，极速部署web程序！")]),t._v(" "),a("p",[t._v("在开发过程中，修改完代码后部署到服务器是一件头疼的事，每一次部署都要上传代码，重启程序，这个过程最少也需要3分钟的时间，作为程序员，怎么能把时间浪费在这种重复操作上呢，我们可以通过一些现有工具的配合，实现码的自动部署，这篇文章的最终实现效果是将本地中修改完的nodejs代码一键运行在服务器端，其它语言同理，只是使用到的工具会有所不同。**")]),t._v(" "),a("h3",{attrs:{id:"一、准备工作：安装node-js和git"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、准备工作：安装node-js和git","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、准备工作：安装node.js和git")]),t._v(" "),a("p",[t._v("我更喜欢用nvm来管理nodejs的版本，nvm需要高版本git支持，而centos yum源里的git版本太低，所以我们要先编译安装新版本的git，关于如何安装，可以看下面这篇文章：")]),t._v(" "),a("p",[t._v("安装新版本git： https://segmentfault.com/a/1190000007134786")]),t._v(" "),a("h5",{attrs:{id:"_1-安装nvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-安装nvm","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.安装nvm")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("yum install curl-devel   #确保curl-devel已经安装\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh | bash\n#执行完后退出终端重新进入\nnvm --version #可以看到nvm版本\n")])])]),a("p",[t._v("如果执行curl安装nvm的过程中出现如下错误：fatal: Unable to find remote helper for 'https'，是因为系统找不到git-remote-https，修改下PATH就好了。")]),t._v(" "),a("h5",{attrs:{id:"_2-修改path："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-修改path：","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.修改PATH：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("vi ~/.bash_profile\n    PATH=$PATH:/usr/libexec/git-core  #在PATH里添加这一行\nsource ~/.bash_profile\n")])])]),a("h5",{attrs:{id:"_3-使用nvm安装指定版本nodejs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用nvm安装指定版本nodejs","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.使用nvm安装指定版本nodejs")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("nvm ls-remote #查看可安装版本\nnvm install v6.2.0 #安装一个较为稳定的版本\nnvm ls  #查看已经安装的版本\nnvm use v4.6.0 #切换版本\nnvm alias default v6.2.0 #设置默认版本\nnode --version  \n")])])]),a("h3",{attrs:{id:"二、使用git自动部署代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、使用git自动部署代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、使用git自动部署代码")]),t._v(" "),a("p",[t._v("接下来我们使用最为优秀的版本控制工具git来同步我在本地和服务器上的代码。")]),t._v(" "),a("p",[a("em",[t._v("先梳理一下大致流程：")])]),t._v(" "),a("ul",[a("li",[t._v("首先在服务器端创建一个文件夹，使用初始化指令使其成为git的中心仓库。")]),t._v(" "),a("li",[t._v("然后在本地电脑新建的项目文件夹中clong上一步在服务器中建立的中心仓库。")]),t._v(" "),a("li",[t._v("在服务器中新建一个要部署代码的目录，并clone中心仓库。")]),t._v(" "),a("li",[t._v("修改服务器中心仓库中的hook文件，实现本地电脑push代码后，自动部署到上一步建立的代码目录。")])]),t._v(" "),a("p",[a("em",[t._v("下面是每一步的具体操作：")])]),t._v(" "),a("h5",{attrs:{id:"_1、在服务器中初始化git中心仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、在服务器中初始化git中心仓库","aria-hidden":"true"}},[t._v("#")]),t._v(" 1、在服务器中初始化git中心仓库")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("mkdir /gitRepo  #新建一个文件夹作为仓库\ncd /gitRepo\ngit init --bare project.git #初始化一个名为progect的仓库\ncd project.git #可以看到新仓库中的各个文件\n")])])]),a("p",[t._v("执行完以上步骤，会在 /gitRepo 文件夹中创建一个名为project的裸库，这个仓库就是之后在客户端的目标仓库")]),t._v(" "),a("h5",{attrs:{id:"_2、在本地电脑克隆远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、在本地电脑克隆远程仓库","aria-hidden":"true"}},[t._v("#")]),t._v(" 2、在本地电脑克隆远程仓库")]),t._v(" "),a("p",[t._v("要在本地连接到仓库首先需要将本地机器的公钥复制给服务器")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ssh-keygen -t rsa  #如果本地还没有生成公钥和秘钥，使用此命令生成\ncat  .ssh/id_rsa.pub #查看生成的公钥，将此公钥复制到服务器的 ~/.ssh/authorized_keys 文件末尾\ngit clone 用户名@服务器地址:/gitRepo/project.git #在当前目录克隆仓库\n")])])]),a("h5",{attrs:{id:"_3、在服务器中配置代码自动部署"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、在服务器中配置代码自动部署","aria-hidden":"true"}},[t._v("#")]),t._v(" 3、在服务器中配置代码自动部署")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("git clong /gitRepo/project.git #在要部署代码的文件夹里克隆仓库\ncp post-receive-sample post-receive #拷贝一份示例文件为post-receive\nvi post-receive\n# 在文件中加入以下指令\n    #!/bin/sh\n    unset GIT_DIR\n    cd 项目路径  #就是进入刚才做克隆操作时的文件夹\n    git pull   #执行拉取指令\nchmod 775 post-receive  #最后一定要将此文件的权限改为可执行\n")])])]),a("p",[t._v("执行完所有步骤之后，每次在本地电脑中提交代码到中心仓库，git便会自动将最新的代码pull到服务器中的代码目录。")]),t._v(" "),a("h5",{attrs:{id:"附：git常用命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#附：git常用命令","aria-hidden":"true"}},[t._v("#")]),t._v(" 附：git常用命令")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('git add . #添加所有文件到git索引\ngit commit -m ""  #提交索引到的文件到缓冲区\ngit push origin master #客户端第一次提交时需要使用此命令提交到远程master分支\ngit push        #提交缓冲区中的文件\ngit rm <filename>  #在git索引中移除文件\ngit rm -r .   #在索引中移除所有文件\n')])])]),a("h3",{attrs:{id:"三、node程序自动运行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、node程序自动运行","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、node程序自动运行")]),t._v(" "),a("p",[t._v("现在通过git提交的代码可以自动部署到服务器的代码目录了，接下来通过使用pm2，在代码变更后让程序自动重启。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("npm install -g pm2  #服务器中全局安装pm2\npm2 start helloworld.js  #使用pm2启动nodejs程序\n")])])]),a("h3",{attrs:{id:"四、编写push脚本，一键将本地程序运行在服务器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、编写push脚本，一键将本地程序运行在服务器","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、编写push脚本，一键将本地程序运行在服务器")]),t._v(" "),a("p",[t._v("现在每次使用git提交代码后，服务器会自动部署代码并重启程序，已经不需要我们再对服务器做任何操作了，是不是已经简化了百分之七十的工作量了？但是我们的目标不仅于此，毕竟每次push还需要三条指令呢，作为新时代的程序员，能让电脑做的决不自己去做。所以我们要通过一个脚本，在每次更改完代码之后一键把本地的代码运行在服务器上。")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# 以下为shell脚本，在mac上可以原生执行，使用Windows的同学可以自行搜索bat脚本写法，类推一下。\ntouch push.sh  #在本地的代码目录新建一个脚本文件。\nchmod +x push.sh #设置脚本权限为可执行\nvim push.sh  #打开脚本，并写入以下命令\n    git add ./\n    read commitMessage  \n    git commit -m commitMessage  \n    git push\n    echo Wow！ 代码一键部署完成！\n\n")])])]),a("p",[t._v("** 最后，激动人心的时刻到了，以后每次修改完代码，执行这个命令："),a("code",[t._v("./push.sh")]),t._v("，然后输入提交信息，好了，你的代码已经在服务器上飞起来了！**")])])},[],!1,null,null,null);n.options.__file="1秒钟极速部署web程序.md";e.default=n.exports}}]);